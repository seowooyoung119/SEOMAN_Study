# Unreal Engine Basic Syntax Quiz Summary (2025-07-03)

This document summarizes the quiz session on Unreal Engine basic syntax, including questions and detailed answers.

---

## 1. `UCLASS()` Macro

**Question:** 언리얼 엔진에서 클래스를 선언할 때 `UCLASS()` 매크로를 사용하는 주된 이유는 무엇인가요?
**Your Answer:** 언리얼의 리플렉션 시스템에 등록하기 위해
**Correct Answer:** `UCLASS()` 매크로는 해당 클래스를 언리얼 엔진의 리플렉션 시스템에 등록하여, 가비지 컬렉션, 직렬화, 블루프린트 노출 등 다양한 엔진 기능을 활용할 수 있도록 합니다.

---

## 2. `UPROPERTY()` Specifiers

**Question:** `UPROPERTY()` 매크로의 `VisibleAnywhere`, `BlueprintReadOnly`, `EditAnywhere`, `BlueprintReadWrite`와 같은 지정자들은 각각 어떤 의미를 가지며, 언제 사용해야 하나요?
**Your Answer:** 비져블에디웨어 - 어디서든 볼 수 있다. 블루프린트리드온리 - 블루프린트 상에서만 수정가능, 에디애니웨어 - 어디서든 수정가능, 블푸프린트 리드라이트 - 브루프린트라면 전부 읽고 쓰기 가능?
**Correct Answer:**
*   **`VisibleAnywhere`**: 언리얼 에디터의 디테일 패널에서 인스턴스나 기본값에 관계없이 해당 프로퍼티를 **볼 수 있지만, 수정은 불가능**합니다.
*   **`BlueprintReadOnly`**: 블루프린트에서 해당 변수의 값을 **읽기만 가능**하며, 수정은 불가능합니다.
*   **`EditAnywhere`**: 언리얼 에디터의 디테일 패널에서 인스턴스나 기본값에 관계없이 해당 프로퍼티를 **수정 가능**합니다.
*   **`BlueprintReadWrite`**: 블루프린트에서 해당 변수의 값을 **읽고 쓰기 모두 가능**합니다.

---

## 3. `UFUNCTION()` Specifiers (`BlueprintPure` vs `BlueprintCallable`)

**Question:** `UFUNCTION()` 매크로의 `BlueprintPure`와 `BlueprintCallable` 지정자의 차이점은 무엇인가요?
**Your Answer:** 블루프린트 퓨어는 그냥 보는 것만 가능, 콜은 수정 가능
**Correct Answer:**
*   **`BlueprintPure`**: 블루프린트에서 호출될 때 **실행 핀(execution pin)이 없는 함수**입니다. 주로 값을 반환하고, 게임 상태를 변경하지 않는(side-effect가 없는) 함수에 사용됩니다. 여러 번 호출해도 항상 같은 결과를 반환해야 합니다.
*   **`BlueprintCallable`**: 블루프린트에서 호출될 때 **실행 핀이 있는 함수**입니다. 게임 상태를 변경하거나(side-effect가 있는) 특정 작업을 수행하는 함수에 사용됩니다.

---

## 4. `GENERATED_BODY()` Macro

**Question:** `GENERATED_BODY()` 매크로는 어떤 역할을 하며, 모든 UObject 파생 클래스에 필수적으로 포함되어야 하는 이유는 무엇인가요?
**Your Answer:** 리플렉션 시스템에서 제대로 작동하기 위해 필요한 코드를 자동으로 생성해주는 역할, 그래서 필수적으로 포함되어야 정상적으로 기능 가능.
**Correct Answer:** `GENERATED_BODY()` 매크로는 언리얼 엔진의 리플렉션 시스템이 클래스의 멤버 변수와 함수에 대한 정보를 수집하고 관리하는 데 필요한 보일러플레이트 코드를 자동으로 생성해줍니다. 이 매크로가 없으면 리플렉션 시스템이 제대로 작동하지 않아 UObject 파생 클래스의 많은 언리얼 엔진 기능(예: 가비지 컬렉션, 직렬화, 블루프린트 통합)을 사용할 수 없게 됩니다.

---

## 5. `AActor` vs `UObject`

**Question:** 언리얼 엔진에서 `AActor`와 `UObject`의 주요 차이점은 무엇이며, 각각 어떤 경우에 사용해야 하나요?
**Your Answer:** 유오브젝트는 모든 클래스의 최상위 클래스로서 실제로 레벨상 배치는 불가능하다. 액터는 레벨에 배치할 수 있는 모든 액터들의 최상위 클래스이며 유오브젝트의 상속을 받은 자식 클래스이기도 하다.
**Correct Answer:**
*   **`UObject`**: 언리얼 엔진의 모든 객체의 최상위 기본 클래스입니다. 리플렉션, 직렬화, 가비지 컬렉션 등의 핵심 기능을 제공하지만, **레벨에 직접 배치될 수 없습니다.** 주로 데이터 컨테이너, 게임 로직, 매니저 클래스 등 시각적인 표현이나 물리적 상호작용이 필요 없는 경우에 사용됩니다.
*   **`AActor`**: `UObject`를 상속받는 클래스로, **레벨에 배치될 수 있는 모든 객체의 기본 클래스**입니다. 시각적인 표현, 물리적 상호작용, 트랜스폼(위치, 회전, 스케일) 등을 가질 수 있습니다. 플레이어 캐릭터, 아이템, 환경 오브젝트 등 게임 월드에 존재하는 모든 것을 나타낼 때 사용됩니다.

---

## 6. `override` Keyword

**Question:** `virtual void BeginPlay() override;`와 같이 `override` 키워드를 사용하는 이유는 무엇인가요?
**Your Answer:** 가상 함수를 재정의하여 해당 클래스가 원하는 로직으로 덮어씌워 쓰기 위함. 클래스의 멤버 함수 오버라이드 시, 객체는 메모리 상에 주소를 새롭게 오버라이드하여 해당 주소의 멤버 함수를 가져오므로, 오버라이드 하지 않았을 때는 기존 부모의 함수 주소를 가져와서 쓰지만, 오버라이드를 할 경우에는 그 주소를 변경하여 내부적으로는 자기 자신 즉, this 에 속한 멤버 함수 주소를 가져오므로 만약에 해당 함수를 새로 정의하여 쓰고 싶거나 수정하고 싶다면 오버라이드하여 써야 한다. 그러나 이 경우에 기존 오버라이드된 함수의 기본 로직을 사용한 이후에 쓰고 싶다면 super 코드를 통해 불러오고 밑에 써야 한다. 그것을 원하지 않을 경우에는... 그냥 쓰면 된다? 이거 맞나?
**Correct Answer:** `override` 키워드를 사용하는 주된 목적은 **가상 함수를 재정의(오버라이드)한다는 것을 명시하고, 컴파일러에게 이를 확인하도록 지시하는 것**입니다. 이는 다음과 같은 이점을 제공합니다:
1.  **컴파일 타임 오류 방지**: 부모 클래스에 해당 시그니처의 가상 함수가 없으면 컴파일 오류를 발생시켜 오타나 시그니처 불일치로 인한 실수를 방지합니다.
2.  **코드 가독성 향상**: 이 함수가 부모 클래스의 가상 함수를 재정의한 것임을 명확히 하여 코드 이해도를 높입니다.
또한, `Super::`를 사용하여 부모 클래스의 구현을 호출할 수 있으며, 필요에 따라 호출하지 않을 수도 있습니다.

---

## 7. `public` Inheritance

**Question:** `ASpartaCharacter : public ACharacter`와 같이 클래스를 상속받을 때 `public` 접근 지정자를 사용하는 이유는 무엇인가요?
**Your Answer:** 퍼블릭으로 상속해야 하는 이유가 뭐임?
**Correct Answer:** `public` 접근 지정자를 사용하여 상속하는 것은 C++에서 **"is-a" 관계**를 나타내는 가장 일반적이고 표준적인 방법입니다.
1.  **인터페이스 유지**: 부모 클래스(`ACharacter`)의 `public` 멤버가 자식 클래스(`ASpartaCharacter`)에서도 `public`으로 유지되어, 부모 클래스의 공개된 기능을 자식 클래스도 그대로 제공하고 사용할 수 있게 합니다.
2.  **다형성(Polymorphism) 활용**: `public` 상속은 다형성을 가능하게 하여, 부모 클래스 타입의 포인터나 참조로 자식 클래스 객체를 가리킬 수 있게 합니다. 이는 코드의 유연성과 확장성을 높입니다.

---

## 8. `#include "CoreMinimal.h"`

**Question:** `#include "CoreMinimal.h"` 헤더 파일은 어떤 역할을 하며, 언리얼 프로젝트에서 자주 포함되는 이유는 무엇인가요?
**Your Answer:** 이게 언리얼 엔진에서 클래스들이 제대로 시스템에 등록되서 돌아가기 위한 최소한의 로직들이 들어가 있는 것으로 알고 있다.
**Correct Answer:** `CoreMinimal.h`는 언리얼 엔진의 가장 기본적인 타입, 매크로, 유틸리티 함수 등을 포함하는 헤더 파일입니다.
*   **역할**: `FString`, `FName`, `TArray`와 같은 컨테이너, `UE_LOG`와 같은 로깅 매크로, 그리고 `UCLASS()`, `UPROPERTY()` 등 UObject 시스템 관련 매크로의 정의 중 일부가 여기에 포함되거나, 이 헤더를 통해 접근 가능하게 됩니다.
*   **자주 포함되는 이유**: 언리얼 엔진 개발에 필수적인 기본 기능을 제공하며, 미리 컴파일된 헤더(PCH)의 일부로 사용되어 전체 컴파일 시간을 단축시키는 데 기여합니다.

---

## 9. Forward Declaration

**Question:** `class USpringArmComponent;`와 같이 클래스 선언 전에 `class` 키워드만 사용하여 선언하는 것을 무엇이라고 부르며, 언제 사용해야 하나요?
**Your Answer:** 전방 선언. 이렇게 하면 컴파일러는 일단 이러한 클래스가 어딘가에 있다는 것만 알고 헤더 파일의 문법적 오류가 없다고 인지한다. 그러면 cpp 파일에서 실제 class를 #inlcude 로 가져와서 쓰면 된다. 이렇게 하는 이유는 헤더에 #incldue 를 할 경우에 서로 순환 참조가 발생할 가능성이 있기 때문이다.
**Correct Answer:**
*   **전방 선언 (Forward Declaration)**: 클래스의 전체 정의 없이 이름만 미리 선언하는 것입니다.
*   **사용하는 이유**:
    1.  **컴파일 시간 단축**: 컴파일러가 실제 클래스 정의를 파싱할 필요가 없어 컴파일 시간을 줄입니다.
    2.  **순환 참조 방지**: 두 개 이상의 헤더 파일이 서로를 `include`해야 하는 순환 참조 문제를 해결할 수 있습니다.
전방 선언은 주로 포인터나 참조 타입으로만 클래스를 사용할 때 유용합니다.

---

## 10. `F` Prefix

**Question:** 언리얼 엔진에서 `FInputActionValue`와 같은 `F` 접두사가 붙은 구조체나 클래스는 일반적으로 어떤 종류의 데이터를 나타내나요?
**Your Answer:** (기억나지 않음)
**Correct Answer:** `F` 접두사는 언리얼 엔진의 명명 규칙 중 하나로, 일반적으로 **`UObject`를 상속받지 않는 구조체(struct) 또는 클래스**를 나타냅니다. 이러한 타입들은 주로 값 타입(Value Type)으로 사용되거나 데이터 컨테이너 역할을 하며, `UObject` 시스템의 가비지 컬렉션 대상이 아닙니다.
